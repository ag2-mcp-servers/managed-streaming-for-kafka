# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-28T12:12:49+00:00



import argparse
import json
import os
from typing import *
from typing import Optional, Union

from autogen.mcp.mcp_proxy import MCPProxy
from autogen.mcp.mcp_proxy.security import APIKeyHeader, BaseSecurity
from fastapi import Header, Path, Query
from pydantic import conint

from models import (
    ApiV2ClustersPostRequest,
    BadRequestException,
    BatchAssociateScramSecretResponse,
    BatchDisassociateScramSecretResponse,
    ConflictException,
    CreateClusterResponse,
    CreateClusterV2Response,
    CreateConfigurationResponse,
    DeleteClusterResponse,
    DeleteConfigurationResponse,
    DescribeClusterOperationResponse,
    DescribeClusterResponse,
    DescribeClusterV2Response,
    DescribeConfigurationResponse,
    DescribeConfigurationRevisionResponse,
    ForbiddenException,
    GetBootstrapBrokersResponse,
    GetCompatibleKafkaVersionsResponse,
    InternalServerErrorException,
    ListClusterOperationsResponse,
    ListClustersResponse,
    ListClustersV2Response,
    ListConfigurationRevisionsResponse,
    ListConfigurationsResponse,
    ListKafkaVersionsResponse,
    ListNodesResponse,
    ListScramSecretsResponse,
    ListTagsForResourceResponse,
    NotFoundException,
    RebootBrokerResponse,
    ServiceUnavailableException,
    TagKeys,
    TooManyRequestsException,
    UnauthorizedException,
    UpdateBrokerCountResponse,
    UpdateBrokerStorageResponse,
    UpdateBrokerTypeResponse,
    UpdateClusterConfigurationResponse,
    UpdateClusterKafkaVersionResponse,
    UpdateConfigurationResponse,
    UpdateConnectivityResponse,
    UpdateMonitoringResponse,
    UpdateSecurityResponse,
    UpdateStorageResponse,
    V1ClustersClusterArnConfigurationPutRequest,
    V1ClustersClusterArnConnectivityPutRequest,
    V1ClustersClusterArnMonitoringPutRequest,
    V1ClustersClusterArnNodesCountPutRequest,
    V1ClustersClusterArnNodesStoragePutRequest,
    V1ClustersClusterArnNodesTypePutRequest,
    V1ClustersClusterArnRebootBrokerPutRequest,
    V1ClustersClusterArnScramSecretsPatchRequest,
    V1ClustersClusterArnScramSecretsPostRequest,
    V1ClustersClusterArnSecurityPatchRequest,
    V1ClustersClusterArnStoragePutRequest,
    V1ClustersClusterArnVersionPutRequest,
    V1ClustersPostRequest,
    V1ConfigurationsArnPutRequest,
    V1ConfigurationsPostRequest,
    V1TagsResourceArnPostRequest,
)

app = MCPProxy(
    contact={
        'email': 'mike.ralphson@gmail.com',
        'name': 'Mike Ralphson',
        'url': 'https://github.com/mermade/aws2openapi',
        'x-twitter': 'PermittedSoc',
    },
    description='\n               <p>The operations for managing an Amazon MSK cluster.</p>',
    license={'name': 'Apache 2.0 License', 'url': 'http://www.apache.org/licenses/'},
    termsOfService='https://aws.amazon.com/service-terms/',
    title='Managed Streaming for Kafka',
    version='2018-11-14',
    servers=[
        {
            'description': 'The Kafka multi-region endpoint',
            'url': 'http://kafka.{region}.amazonaws.com',
            'variables': {
                'region': {
                    'default': 'us-east-1',
                    'description': 'The AWS region',
                    'enum': [
                        'us-east-1',
                        'us-east-2',
                        'us-west-1',
                        'us-west-2',
                        'us-gov-west-1',
                        'us-gov-east-1',
                        'ca-central-1',
                        'eu-north-1',
                        'eu-west-1',
                        'eu-west-2',
                        'eu-west-3',
                        'eu-central-1',
                        'eu-south-1',
                        'af-south-1',
                        'ap-northeast-1',
                        'ap-northeast-2',
                        'ap-northeast-3',
                        'ap-southeast-1',
                        'ap-southeast-2',
                        'ap-east-1',
                        'ap-south-1',
                        'sa-east-1',
                        'me-south-1',
                    ],
                }
            },
        },
        {
            'description': 'The Kafka multi-region endpoint',
            'url': 'https://kafka.{region}.amazonaws.com',
            'variables': {
                'region': {
                    'default': 'us-east-1',
                    'description': 'The AWS region',
                    'enum': [
                        'us-east-1',
                        'us-east-2',
                        'us-west-1',
                        'us-west-2',
                        'us-gov-west-1',
                        'us-gov-east-1',
                        'ca-central-1',
                        'eu-north-1',
                        'eu-west-1',
                        'eu-west-2',
                        'eu-west-3',
                        'eu-central-1',
                        'eu-south-1',
                        'af-south-1',
                        'ap-northeast-1',
                        'ap-northeast-2',
                        'ap-northeast-3',
                        'ap-southeast-1',
                        'ap-southeast-2',
                        'ap-east-1',
                        'ap-south-1',
                        'sa-east-1',
                        'me-south-1',
                    ],
                }
            },
        },
        {
            'description': 'The Kafka endpoint for China (Beijing) and China (Ningxia)',
            'url': 'http://kafka.{region}.amazonaws.com.cn',
            'variables': {
                'region': {
                    'default': 'cn-north-1',
                    'description': 'The AWS region',
                    'enum': ['cn-north-1', 'cn-northwest-1'],
                }
            },
        },
        {
            'description': 'The Kafka endpoint for China (Beijing) and China (Ningxia)',
            'url': 'https://kafka.{region}.amazonaws.com.cn',
            'variables': {
                'region': {
                    'default': 'cn-north-1',
                    'description': 'The AWS region',
                    'enum': ['cn-north-1', 'cn-northwest-1'],
                }
            },
        },
    ],
)


@app.get(
    '/api/v2/clusters',
    description=""" 
            <p>Returns a list of all the MSK clusters in the current Region.</p> """,
    tags=['cluster_operations', 'kafka_resource_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_clusters_v2(
    cluster_name_filter: Optional[str] = Query(None, alias='clusterNameFilter'),
    cluster_type_filter: Optional[str] = Query(None, alias='clusterTypeFilter'),
    max_results: Union[
        Optional[conint(ge=1, le=100)], Optional[str], Optional[str], Optional[str]
    ] = Query(None, alias='maxResults'),
    next_token: Union[
        Optional[str], Optional[str], Optional[str], Optional[str]
    ] = Query(None, alias='nextToken'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/api/v2/clusters',
    description=""" 
            <p>Creates a new MSK cluster.</p> """,
    tags=['cluster_security_settings'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def create_cluster_v2(
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: ApiV2ClustersPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/api/v2/clusters/{clusterArn}',
    description=""" 
            <p>Returns a description of the MSK cluster whose Amazon Resource Name (ARN) is specified in the request.</p> """,
    tags=['cluster_operations', 'cluster_security_settings'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def describe_cluster_v2(
    cluster_arn: str = Path(..., alias='clusterArn'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/clusters',
    description=""" 
            <p>Returns a list of all the MSK clusters in the current Region.</p> """,
    tags=['cluster_operations', 'kafka_resource_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_clusters(
    cluster_name_filter: Optional[str] = Query(None, alias='clusterNameFilter'),
    max_results: Union[
        Optional[conint(ge=1, le=100)], Optional[str], Optional[str], Optional[str]
    ] = Query(None, alias='maxResults'),
    next_token: Union[
        Optional[str], Optional[str], Optional[str], Optional[str]
    ] = Query(None, alias='nextToken'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v1/clusters',
    description=""" 
            <p>Creates a new MSK cluster.</p> """,
    tags=['cluster_security_settings'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def create_cluster(
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: V1ClustersPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v1/clusters/{clusterArn}',
    description=""" 
            <p>Deletes the MSK cluster specified by the Amazon Resource Name (ARN) in the request.</p> """,
    tags=['cluster_operations', 'cluster_security_settings'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_cluster(
    cluster_arn: str = Path(..., alias='clusterArn'),
    current_version: Optional[str] = Query(None, alias='currentVersion'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/clusters/{clusterArn}',
    description=""" 
            <p>Returns a description of the MSK cluster whose Amazon Resource Name (ARN) is specified in the request.</p> """,
    tags=['cluster_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def describe_cluster(
    cluster_arn: str = Path(..., alias='clusterArn'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/clusters/{clusterArn}/bootstrap-brokers',
    description=""" 
            <p>A list of brokers that a client application can use to bootstrap.</p> """,
    tags=['cluster_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_bootstrap_brokers(
    cluster_arn: str = Path(..., alias='clusterArn'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/v1/clusters/{clusterArn}/configuration',
    description=""" 
            <p>Updates the cluster with the configuration that is specified in the request body.</p> """,
    tags=['cluster_operations', 'cluster_security_settings'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def update_cluster_configuration(
    cluster_arn: str = Path(..., alias='clusterArn'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: V1ClustersClusterArnConfigurationPutRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/v1/clusters/{clusterArn}/connectivity',
    description=""" 
            <p>Updates the cluster's connectivity configuration.</p> """,
    tags=['cluster_operations', 'cluster_security_settings'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def update_connectivity(
    cluster_arn: str = Path(..., alias='clusterArn'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: V1ClustersClusterArnConnectivityPutRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/v1/clusters/{clusterArn}/monitoring',
    description=""" 
            <p>Updates the monitoring settings for the cluster. You can use this operation to specify which Apache Kafka metrics you want Amazon MSK to send to Amazon CloudWatch. You can also specify settings for open monitoring with Prometheus.</p> """,
    tags=['monitoring_settings_management', 'cluster_security_settings'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def update_monitoring(
    cluster_arn: str = Path(..., alias='clusterArn'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: V1ClustersClusterArnMonitoringPutRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/clusters/{clusterArn}/nodes',
    description=""" 
            <p>Returns a list of the broker nodes in the cluster.</p> """,
    tags=['cluster_operations', 'kafka_resource_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_nodes(
    cluster_arn: str = Path(..., alias='clusterArn'),
    max_results: Union[
        Optional[conint(ge=1, le=100)], Optional[str], Optional[str], Optional[str]
    ] = Query(None, alias='maxResults'),
    next_token: Union[
        Optional[str], Optional[str], Optional[str], Optional[str]
    ] = Query(None, alias='nextToken'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/v1/clusters/{clusterArn}/nodes/count',
    description=""" 
            <p>Updates the number of broker nodes in the cluster.</p> """,
    tags=['node_operations', 'cluster_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def update_broker_count(
    cluster_arn: str = Path(..., alias='clusterArn'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: V1ClustersClusterArnNodesCountPutRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/v1/clusters/{clusterArn}/nodes/storage',
    description=""" 
            <p>Updates the EBS storage associated with MSK brokers.</p> """,
    tags=['cluster_operations', 'node_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def update_broker_storage(
    cluster_arn: str = Path(..., alias='clusterArn'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: V1ClustersClusterArnNodesStoragePutRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/v1/clusters/{clusterArn}/nodes/type',
    description=""" 
            <p>Updates EC2 instance type.</p> """,
    tags=['cluster_operations', 'node_operations', 'cluster_security_settings'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def update_broker_type(
    cluster_arn: str = Path(..., alias='clusterArn'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: V1ClustersClusterArnNodesTypePutRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/clusters/{clusterArn}/operations',
    description=""" 
            <p>Returns a list of all the operations that have been performed on the specified MSK cluster.</p> """,
    tags=['cluster_operations', 'kafka_resource_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_cluster_operations(
    cluster_arn: str = Path(..., alias='clusterArn'),
    max_results: Union[
        Optional[conint(ge=1, le=100)], Optional[str], Optional[str], Optional[str]
    ] = Query(None, alias='maxResults'),
    next_token: Union[
        Optional[str], Optional[str], Optional[str], Optional[str]
    ] = Query(None, alias='nextToken'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/v1/clusters/{clusterArn}/reboot-broker',
    description=""" Reboots brokers. """,
    tags=['broker_configuration'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def reboot_broker(
    cluster_arn: str = Path(..., alias='clusterArn'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: V1ClustersClusterArnRebootBrokerPutRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/clusters/{clusterArn}/scram-secrets',
    description=""" 
            <p>Returns a list of the Scram Secrets associated with an Amazon MSK cluster.</p> """,
    tags=[
        'cluster_operations',
        'kafka_resource_management',
        'cluster_operation_tracking',
    ],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_scram_secrets(
    cluster_arn: str = Path(..., alias='clusterArn'),
    max_results: Union[
        Optional[conint(ge=1, le=100)], Optional[str], Optional[str], Optional[str]
    ] = Query(None, alias='maxResults'),
    next_token: Union[
        Optional[str], Optional[str], Optional[str], Optional[str]
    ] = Query(None, alias='nextToken'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/v1/clusters/{clusterArn}/scram-secrets',
    description=""" 
            <p>Disassociates one or more Scram Secrets from an Amazon MSK cluster.</p> """,
    tags=['scram_secret_handling', 'cluster_security_settings'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def batch_disassociate_scram_secret(
    cluster_arn: str = Path(..., alias='clusterArn'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: V1ClustersClusterArnScramSecretsPatchRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v1/clusters/{clusterArn}/scram-secrets',
    description=""" 
            <p>Associates one or more Scram Secrets with an Amazon MSK cluster.</p> """,
    tags=['scram_secret_handling', 'cluster_security_settings'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def batch_associate_scram_secret(
    cluster_arn: str = Path(..., alias='clusterArn'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: V1ClustersClusterArnScramSecretsPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/v1/clusters/{clusterArn}/security',
    description=""" 
            <p>Updates the security settings for the cluster. You can use this operation to specify encryption and authentication on existing clusters.</p> """,
    tags=['cluster_security_settings'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def update_security(
    cluster_arn: str = Path(..., alias='clusterArn'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: V1ClustersClusterArnSecurityPatchRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/v1/clusters/{clusterArn}/storage',
    description=""" Updates cluster broker volume size (or) sets cluster storage mode to TIERED. """,
    tags=['cluster_operations', 'cluster_security_settings'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def update_storage(
    cluster_arn: str = Path(..., alias='clusterArn'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: V1ClustersClusterArnStoragePutRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/v1/clusters/{clusterArn}/version',
    description=""" 
            <p>Updates the Apache Kafka version for the cluster.</p> """,
    tags=['cluster_operations', 'cluster_security_settings'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def update_cluster_kafka_version(
    cluster_arn: str = Path(..., alias='clusterArn'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: V1ClustersClusterArnVersionPutRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/compatible-kafka-versions',
    description=""" 
            <p>Gets the Apache Kafka versions to which you can update the MSK cluster.</p> """,
    tags=['cluster_operations', 'cluster_security_settings'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_compatible_kafka_versions(
    cluster_arn: Optional[str] = Query(None, alias='clusterArn'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/configurations',
    description=""" 
            <p>Returns a list of all the MSK configurations in this Region.</p> """,
    tags=['cluster_operation_tracking', 'kafka_resource_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_configurations(
    max_results: Union[
        Optional[conint(ge=1, le=100)], Optional[str], Optional[str], Optional[str]
    ] = Query(None, alias='maxResults'),
    next_token: Union[
        Optional[str], Optional[str], Optional[str], Optional[str]
    ] = Query(None, alias='nextToken'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v1/configurations',
    description=""" 
            <p>Creates a new MSK configuration.</p> """,
    tags=['cluster_security_settings'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def create_configuration(
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: V1ConfigurationsPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v1/configurations/{arn}',
    description=""" 
            <p>Deletes an MSK Configuration.</p> """,
    tags=['cluster_security_settings'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_configuration(
    arn: str,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/configurations/{arn}',
    description=""" 
            <p>Returns a description of this MSK configuration.</p> """,
    tags=['cluster_security_settings'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def describe_configuration(
    arn: str,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/v1/configurations/{arn}',
    description=""" 
            <p>Updates an MSK configuration.</p> """,
    tags=['broker_configuration', 'cluster_security_settings'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def update_configuration(
    arn: str,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: V1ConfigurationsArnPutRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/configurations/{arn}/revisions',
    description=""" 
            <p>Returns a list of all the MSK configurations in this Region.</p> """,
    tags=['kafka_resource_management', 'kafka_version_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_configuration_revisions(
    arn: str,
    max_results: Union[
        Optional[conint(ge=1, le=100)], Optional[str], Optional[str], Optional[str]
    ] = Query(None, alias='maxResults'),
    next_token: Union[
        Optional[str], Optional[str], Optional[str], Optional[str]
    ] = Query(None, alias='nextToken'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/configurations/{arn}/revisions/{revision}',
    description=""" 
            <p>Returns a description of this revision of the configuration.</p> """,
    tags=['config_revision_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def describe_configuration_revision(
    arn: str,
    revision: int = ...,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/kafka-versions',
    description=""" 
            <p>Returns a list of Apache Kafka versions.</p> """,
    tags=['kafka_resource_management', 'resource_tag_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_kafka_versions(
    max_results: Union[
        Optional[conint(ge=1, le=100)], Optional[str], Optional[str], Optional[str]
    ] = Query(None, alias='maxResults'),
    next_token: Union[
        Optional[str], Optional[str], Optional[str], Optional[str]
    ] = Query(None, alias='nextToken'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/operations/{clusterOperationArn}',
    description=""" 
            <p>Returns a description of the cluster operation specified by the ARN.</p> """,
    tags=['cluster_operations', 'cluster_operation_tracking'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def describe_cluster_operation(
    cluster_operation_arn: str = Path(..., alias='clusterOperationArn'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/tags/{resourceArn}',
    description=""" 
            <p>Returns a list of the tags associated with the specified resource.</p> """,
    tags=['resource_tag_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_tags_for_resource(
    resource_arn: str = Path(..., alias='resourceArn'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v1/tags/{resourceArn}',
    description=""" 
            <p>Adds tags to the specified MSK resource.</p> """,
    tags=['resource_tag_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def tag_resource(
    resource_arn: str = Path(..., alias='resourceArn'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: V1TagsResourceArnPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v1/tags/{resourceArn}#tagKeys',
    description=""" 
            <p>Removes the tags associated with the keys that are provided in the query.</p> """,
    tags=['resource_tag_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def untag_resource(
    resource_arn: str = Path(..., alias='resourceArn'),
    tag_keys: TagKeys = Query(..., alias='tagKeys'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="MCP Server")
    parser.add_argument(
        "transport",
        choices=["stdio", "sse", "streamable-http"],
        help="Transport mode (stdio, sse or streamable-http)",
    )
    args = parser.parse_args()

    if "CONFIG_PATH" in os.environ:
        config_path = os.environ["CONFIG_PATH"]
        app.load_configuration(config_path)

    if "CONFIG" in os.environ:
        config = os.environ["CONFIG"]
        app.load_configuration_from_string(config)

    if "SECURITY" in os.environ:
        security_params = BaseSecurity.parse_security_parameters_from_env(
            os.environ,
        )

        app.set_security_params(security_params)

    mcp_settings = json.loads(os.environ.get("MCP_SETTINGS", "{}"))

    app.get_mcp(**mcp_settings).run(transport=args.transport)
